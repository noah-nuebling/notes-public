
///
/// Swuft aka objc3
///     Attempt at python-y-fying objc while keeping objc semantics
///     - objc 3.0
///     - What Swift should have been
///     Details:
///         - Strict superset of plain C, 
///             with simple, consistent extensions
///         - Language extensions on C:
///             - Method calls look like `obj.do_thing(arg1=xyz, arg2=zyx)` instead of `[obj doThingWithArg1:xyz arg2: zyx]`
///                 -> `.` is totally unambiguous in this context I think - so no issues interfering with C.
///                 Backward compat: `obj.do_thing(arg1=xyz, arg2=zyx)` would get imported into objc as [obj do_thing_arg1: xyz arg2: zyx]      (the selector in the objc runtim in both cases is (do_thing_arg1:arg2:))
///                 Forward compat: `[obj doThingWithArg1:xyz arg2: zyx]` imported into Swuft as obj.doThingWithArg1(xyz, arg2=zyx)
///                     -> Selector transformation rules for Swuft: 
///                         - `Last underscore before first `:` in the selector` becomes `opening parens`    
///                         -  `:` becomes `=`                                            (We could also use `:` in swuft directly to simplify things further – might make things slightly less readable – but removing a special-case is good.)
///                         -> These rules creates discrepancy between selector names in objc runtime and how they are used in Swuft. 
///                             (Although the discrepancy would follow very simple, predictable rules, unlike Swift. Plus objc-style selectors and swuft-style selectors could still be used easily and consistently 
///                                 from either language, and you could just slowly introduce new swuft-style methods, and mark the old ones as 'superseeded for swuft' and hide them from autocomlete or something.)
///             - string literals, number literals, dict literals etc are the same as objc 2.0 (prefixed with @)
///             - Converting primitives to objects is the same as objc 2.0 (E.g. @(some_int))
///             - Has automatic reference counting for blocks and objects like objc 2.0
///             - Has auto keyword for type-inference
///                 (C already has __auto_type, this is just a rename)
///             - All objects prefixed with @. E.g. `NSString *` -> `@str`
///                 - Might seem noisy, but this way you can leave out the `*` since @ already indicates a reference type
///             - Maybe add `?` for optionals 
///                     and enable compiler warnings by default for when you accidentally convert sth optional into a non-optional type. (Similar to Swift but implemented in a lightweight way on the linter level, 
///                     rather than deeply integrated into the syntax with iflet and so on.)
///             - Ideas: 
///                     (That I'm not sure are worth making the language more complicated for)
///                 - Idea: Objects can be initialized with @obj(arg=xyz) (Similar to Swift)
///                     - Could either be magic syntax sugar for [[NSObject alloc] initWithArg: xyz] or a new __init__(t1 arg1, t2 arg2, ...) 'dunder method' (like python) -- I think I like the dunder method approach, to keep things transparent and opt-in.
///                     - @obj.alloc().init() is annoying but @obj.new() wouldn't be too bad -> Maybe this could be addressed at the library level
//                  - Idea: dunder methods / Operator overloading
///                     - You could overload operators like >, <, ==, !=, +=, ... to work on objects. E.g. == could call NSObject's isEqual: 
//                          Contra: if you have very short method names for common ops like .eq(), .add(), it's not that bigga difference and removes some semantic clarity and simplicity... 
///                         ... But still might be a good idea. You could do @>, @<, @==, ..., but I feel like that's not much more readable than method-calls. @> looks like a fish or something.
///                         To flexibly support this, you could add special methods to @obj (NSObject) like __eq__, __lt__, etc. which map to the operators (Just like Python 'dunder methods')
///                             or you could just map the standard NSObject method names (`isEqual:` etc.) to the operators... That seems simpler with no concrete downsides I can think of. 
///                             (Although it feels a bit wrong somehow. Maybe too much 'magic'. I think I like the transparency of dunder methods.)
///                 - Idea: Builtin dataclasses
///                     - Just like Python @dataclass decorator, (or MFDataClass, maybe a bit easier to use) – not sure how to implement this, but would be very valuable to create essentially 'struct with 
///                         runtime reflection and automatic serialization, automatic __eq__ implementation, and autogenerated initializer'
///                         Since we already have the `@prop` directive doing magic codegen in the compiler (like objc2.0 alredy does for @property) (Although I don't know if I like that). We could also magically codegen 
///                         initializers for 'dataclasses' maybe? ... Not sure how to implement this but sth like dataclasses would be nice. 
///                             (MFDataClass is implemented with objc-runtime-reflection and macros for some compile-time codegen of initializers. 
///                                     In python you'd probably do this all at runtime. That's probably also possible in the objc runtime but then you don't get autocomplete for the initializers I suppose? 
///                                     – I do think you want some compile-time generation here, but compiler-magic feels bad. Maybe just stick with C macros? Or add more powerful compile-time-execution at some point?)
///                 - Idea: Built-in ways for to-object-conversion
///                     E.g. calling [obj description] in regular objc is akin to converting to a string. In python you'd use str(obj). 
///                     Perhaps we could extend C casting (which already does conversions for simple things like int->float to do object conversions – so you'd do (@str)obj.
///                     ... But this feels a bit magical, and C casting auto-conversions only seem to work for very primitive types (E.g. (char *)53 doesn't do a complex conversion to a string.) ... Don't actually understand what the philosophy behind C casting design is.
///                     But maybe you could add, as a library feature, some converting initializers like @str(obj), @str(int=n), @str(uint64=n), ...
///                 - Idea: Ideas for other python syntax sugar:
///                     - Could support slicing and subscripting just like python (__getitem__ dunder method)
///                     - Could support list comprehensions
///                 - Idea: String interpolation like python: E.g. @f"Meaning of %{str_life}: %{str_fourtytwo}"
///                     Otherwise we could just do `.format()` without any language extensions – as described below
///                 - Id        ea: Could introduce a more convenient for-loop
///                     - The `loopc()` used below is a pure C macro I use in my projects and feels convenient enough for me, for the common case of looping through all elements in a list. But other ppl might find that weird.
///                     Objc 2.0 for...in feels too inflexible and magical for a languages feature imo. Maybe you could introduce something pythony or just add sth like loopc to the stdlib and keep control-flow sytnax in pure C.
///                 - Idea: Repl
///                     - Then it could be a full-on python competitor perhaps. 
///                     - Probably hard to implement
///                     - ... But JIT/interpreter could also be leveraged for powerful compile-time-execution in theory.
///                         - If you do crazy compiler stuff, maybe you could also prove that a method is never rerouted, and therefore make its dispatch static... That's that 'micro optimization' stuff that I think hurts Swift and CPP though.
///                     
///         - Changes to Apple's libraries:
///             - Object & method naming abbreviated, in the spirit of C/Python
///             - @str can be formatted with `.format`. E.g. @"Meaning of life: %d".format(42)
///             - Methods added globally to @obj (NSObject) in categories are namespaced with prefixes indicating their method family.
///                 E.g. valueForKey: -> kvc_get()
///             - Abbreviations of commonly used methods:
///                 - isEqual: -> eq()
///                 - description -> desc()
///                 - containsObject: -> contains()
///                 - objectAtIndex: -> at()
///                 - lastObject: -> last()
///                 -> Alternatively/(additionally?) you could support python-style dunder methods like: __eq__, __str__ __repr__, __contains__, __getitem__
///                     
///             -Idea:  Maybe add talloc() (temp-allocator) which by default gets cleared once per runLoop (Whereever NSAutoreleasePool is cleared) 
///                 – that way you could perhaps use lower level C stuff much more painlessly. (E.g. when returning a C string or C array from a function)
///                     ... But why not just wrap the C string / C array in an object in those cases? Should have almost 0 overhead (an objc instance is just syntax sugar over a malloced struct AFAIK) -> Feel like there's no need for talloc.
///         - Problems:
///             - Not sure how to declare a method with unnamed params
///
///     Summary:
///         - 95% of the benefits here over existing objc are simply from renaming Apple's library methods to be more concise, and adopting a more 'mainstream' method-call syntax.


/// --- MARK: [MFDataClass description] in different languages

/// Swuft

- @str description() {

    @str content = @"";
    @arr<@str> propnames = self.class().all_propnames();
    if (propnames.count() > 0) {
    
        /// Check for circular refs
        ///     This prevents infinite loops if there are circular references in the datastructure. But [NSDictionary -description] seems to just infinite-loop in this case... Maybe this was overkill.
        auto thread_local visited = @mutarr();
        auto s = @((uintptr_t)self);
        bool found_circref = visited.contains(s);
        visited.add(s);
        defer {
            assert(visited.last().eq(s));
            visited.pop();
        }
        
        /// Get description of props
        if ((0))
            content = self.asplist(secure=False).desc();
        else if (found_circref)
            content = @"<This object has appeared in the description before. Stopping here to prevent infinite recursion.>";
        else {
            auto _content = @mutstr();
            loopc(i, propnames.count()) {
                @str name = propnames.at(i);
                @str? value = self.kvc_get(name).desc();
                _content.append(@"%@: %@".format(name, value));
                bool notlast = (i < propnames.count() - 1);
                if (notlast)
                    _content.append(@"\n");
            }
            content = _content;
        }
    }
}


/// Rough Python equivalent

- description(self):

    content = ""
    propNames = type(self).all_propnames()
    if propNames.count() > 0:
    
        # Check for circular refs
        #     This prevents infinite loops if there are circular references in the datastructure. But [NSDictionary -description] seems to just infinite-loop in this case... Maybe this was overkill.
        tloc = threading.local() 
        tloc.visited = []
        s = id(self)
        found_circref = (s in tloc.visited)
        tloc.visited += s
        defer:
            assert tloc.visited[-1] == s
            tloc.visited.pop()
        
        # Get description of props
        if 0:
            content = str(self.asplist(secure=False))
        elif found_circref:
            content = "<This object has appeared in the description before. Stopping here to prevent infinite recursion.>"
        else:
            _content = "";
            
            for i, name in enumerate(propNames):
                value: str|None = str(self[name])
                _content += f"\(name): \(value)"
                notlast = (i < propNames.count() - 1);
                if notlast:
                    _content += "\n"

            content = _content;

/// Original objc:

- (NSString *) description {

    NSString *content = @"";
    NSArray<NSString *> *propNames = [self.class allPropertyNames];
    if (propNames.count > 0) {
    
        /// Check for circular refs
        ///     This prevents infinite loops if there are circular references in the datastructure. But [NSDictionary -description] seems to just infinite-loop in this case... Maybe this was overkill.
        NSMutableArray *const visitedObjects = threadobject([[NSMutableArray alloc] init]);
        NSNumber *s = @((uintptr_t)self); /// We cast self to an NSNumber so that we effectively do pointer-based equality checking instead of using the full `-isEqual` implementation.
        BOOL didFindCircularRef = [visitedObjects containsObject: s];
        [visitedObjects addObject: s];
        MFDefer ^{
            assert([[visitedObjects lastObject] isEqual: s]);
            [visitedObjects removeLastObject];
        };
        
        /// Get description of props
        if ((0))
            content = [self asPlistWithRequireSecureCoding: NO].description;
        else if (didFindCircularRef)
            content = @"<This object has appeared in the description before. Stopping here to prevent infinite recursion.>";
        else {
            NSMutableString *_content = [NSMutableString string];
            
            for (int i = 0; i < propNames.count; i++) {
                NSString *name = propNames[i];
                NSString *_Nullable value = [[self valueForKey: name] description]; /// If this is nil, NSString will just insert "(null)" iirc || `-description` is the recursive call that might cause infinite loops if there are circular refs
                [_content appendFormat:@"%@: %@", name, value];
                bool isNotLast = (i < propNames.count - 1);
                if (isNotLast) {
                    [_content appendString:@"\n"];
                }
            }
            content = _content;
        }
    }
}

/// --- MARK: class definition in different languages

/// Swuft

@class @CustomString;        /// Class forward-declaration

@class @CustomString : @str { /// Class declaration

    /// Implicitly public ivar
    @str ivar;                            
    
    /// Ivar with access modifier
    @private   @str  ivar_str_private;
    @protected @num  ivar_num_protected;
    @public    @dict ivar_dict_public;

    /// Properties
    ///     -> Simply add @prop before the ivar to autogenerate a getter and setter
    @prop NSInteger ivar;
    @prop(atomic=0, readonly=0, copy_on_set=0, getter=getterName, setter=setterName) NSInteger prop;    /// Fully specified @prop directive – the arguments are mostly named boolean flags, unlike confusing objc 2.0 args
    @prop @obj? __weak object;                                                                          /// Ownership and nullability are expressed as part of type-system, not part of the @prop directive (like objc 2.0) – this is consistent with the rest of the language


    /// Method declarations
    ///     -> They appear inside the { } together with the ivars, not inside @interface/@end like objc 2.0
    + @str do_other_thing(int a1, @str a2);
        /// Can be invoked with @CustomString.do_thing(a1=..., a2=...)

    - @str do_thing(@obj plist, nsplistpickle_fmt format, nsplistpickle_options options, @nserror err) { /// The class declaration can directly contain method *definitions* (useful e.g. if it appears in a .m file instead of a .h file)
        /// Can be invoked with ((@CustomString)obj).do_thing(plist=..., format=..., options=..., err=...)
        ...
    }
}

@class @CustomString { /// Class definition – This would usually go in the .m file

    + @str do_other_thing(int a1, @str a2) { /// Definition of previous declaration
        ...
    }
}

/// Python

    /// Too lazy to write

/// ObjC

    /// Too lazy to write

/// ----------------


/// Update: [Nov 2025] Most of changes are basically not worth it. Objc is already fine. It just looks ugly.
///     Let me try another attempt of cleaning up the objc syntax with fewer changes and with my current tastes which favor simplicity and consistency more:

///     (Changes:)
///         Add auto (already in objc via macro)
//          Remove const – who cares
//          Remove _Nullable - who cares
//          No more 'NSMutableArray' just Array - who cares about mutability? Not worth the complexity. 
//              It's all NSCFArray or whatever under the hood anyway, so no speed penalty I think.
//          Remove NS prefixes – NSArray -> Array. Less ugly. More appealing to noobs.
//          Move NSArray (now just 'Array') out of Foundation and into a standard library (or just make Foundation the standard library) 
//          Make a repl / JIT
//              For C generally. LLDB already has an C/objc interpreter, I'd assume gdb as well. Should be possible.
//              -> Nice to have for a scripting language 
//          Provide the standard library open source and cross-platform, so that objc actually becomes viable to use outside of Apple ecosystem. 
//              I think it could be a viable choice on linux over Python for scripting with some performance requirements. 
//              (built into clang/gcc, fast, can call C APIs like stat() directly without ffi, automatic memory management, generic lists, syntax sugar like Python. 
//              Basically anyone with a c compiler gets this nice dynamic scripting environment for 
//              C that can call all the UNIX file/system APIs natively and has a repl and is fast and stuff. – That's actually useful for Linux programmers I think.)
//          Method-calls: 
//              Dot-syntax: 
//                  Old: auto x = [[[obj thingWithThing:thing andThing:otherThing] description] UTF8String]
//                  New: auto x = obj.[thingWithThing: thing andThing: otherThing].[description].[UTF8String]
//                  -> Solves only real painpoint with current objc method calls: 
//                          Having to add `[` *on the left* of the `obj` when you wanna chain a method call (on its *right*).
//                  -> Absolutely no abstraction or ambiguity about what the selector string at runtime is.
//                  -> Still matches common notation for methods: `-[thingWithThing:andThing:]`
//                  -> No ambiguity or overlap with 'native' C syntax.
//                  -> 'Feels' sort of natural I think. Space is no longer a 'method call' operator. It's `.` like normal language. 
//                      Dot is also easier to parse visual when method chaining. Using [] for selectors feels 'natural' because it's 
//                      commonly used to look up something on an object via a key (array/dict), and you 
//                      *are* looking up the method by selector-string -> Checks out.
//              Full-smalltalk:
//                  auto x = obj [thingWithThing: thing andThing: otherThing] description UTF8String;
//                  -> ULTRA clean
//                      -> Objc go from the ugliest langauge to the prettiest language.
//                  -> Can't think of a reason why this won't parse
//                      Note: If you port pure smalltalk syntax to C, 
//                          then `obj parseThing: thing. description` is ambiguous because `thing.description` is struct-member-access.
//                          But we solve that by simply wrapping methods with args in []
//                  -> Why didn't they do this when they originally created objc??
//                  
//          Change generics syntax from `NSArray<String *> *` to `Array [String *] *`
//              -> Looks nicer and is more reminiscent / consistent with how you use the object.(You call a .[method] on the `Array *` to get a `String *` out of it). 
//                  This matches with native C design where declaration syntax follows usage syntax.
//          Make it customary to use space after `:` in selectors. 
//              `[obj thingWithThing:thing andThing:otherThing]` vs
//              `obj.[thingWithThing: thing andThing: otherThing]` 
//              -> This looks prettier and closer to how other languages (including Swift) format syntax involving `:`. And it's easier to grok at a glance.
//          Keep being a C superset - C is great. 
//              - C is fast and simple and lets you understand what the computer is actually doing.
//              - C is the native language of the system. You can call native UNIX C APIs like link, stat, etc and 
//                  wrap the results in @() to avoid manual memory management and put them into superfast dynamic collections 
//                  like NSDictionary (now Dictionary) for javascript-like expressiveness.
//                  – this makes for a great and super fast scripting language.
//              - Make unboxing even easier. Add protocol for .[sizeof] and .[unbox: &buffer] methods to copy collection contents into a C array super easily.
//              -> Lean into the strengths of being a C superset.

//              Weird idea 'boxing cast': Make boxing syntax look like C-cast: `@(str)` -> `@(auto) str`
//                  Interesting thing is this could take params for boxing C arrays / buffers.
//                      char *:
//                          char *heapStringFromCAPI;
//                          auto obj = @(__free String *) heapStringFromCAPI; // heapStringFromCAPI is freed and set to NULL after this.
//                      int *:
//                          Array [Number *] *boxedInts = @(__count(int n) __free auto) (int *)getHeapInts(&n); 
//                              -> `int n` only exists for the scope after @()
//                              -> Can also declare `int n` beforehand and use __count(n)
//                              -> Same semantics as `for (int i = 0;;)` -> not too weird.
//                      int[];
//                          int stackStuff[10] = ...;
//                          Array [Number *] *obj = @(auto) stackStuff; // Just infers the size automatically
//                  
//                      -> Not sure this is too magical, but might be useful enough for calling C APIs to be worth it for a 'UNIX-native system-scripting language'.
//                      -> Maybe just make a macro for the C-buffer boxing? It's basically just boxing each element and putting them in an Array *. 
//                      -> Weird: It's strange that the element size is inferred from the c type but the element count is specified in the @(boxed cast). 
//                          Those things seem maybe too related to split up like this? ... no its fine scrap that.
//                  Could have parallel 'unboxing cast' feature:
//                      uint64_t i = @(uint64_t)myBoxedNumber;
//                      uint64_t i = [myBoxedNumber unsignedLongLongValue]; /// current objc
//                      -> The @() syntax then generally means 'convert between object<->primitive' – which I think is powerful and simple.
//          for range(i, propNames.count)
//             Just a convenience macro. Could do this in current objc, too. looks nicer than the 'loopc' macros I'm using in MMF, but could work the same. 
//              (Work like python range())
//          defer -> That's nice I guess.
//          Just use .[new] to create new instances 
//              (This isn't common in current objc because in the 2000s they were crazy 
//              and preferred [[Class alloc] init] because more verbose = more 'explicit' = better or something? 
//              Also -[new] had to be autoreleased before ARC, but -[array] didn't so that was preferred for convenience. 
//              But with ARC, you should just use .[new] everywhere.)
//          Syntax sugar on objects, 
//              like:
//                  += to append to strings / arrays. 
//                  arr[2:10:-1] for substring/subarray sugar (like python slicing syntax)
//                  etc.
//                  Maybe even add Python-like list/dict/set comprehensions.
//                  -> Make working with basic collections super easy and expressive. 
//                  Sugar would be implemented with new protocols that define methods like [sliceWithLower:upper:step:] which anyone could adopt. 
//                      Maybe they should have underscores to mark them as 'sugar methods' so they're easy to spot and don't conflict. (Python does this)
//          Keep the long method names on lesser used APIs like NSImage or whatever 
//              -> Those actually benefit from the explicitness.
//          Fix ARC to work with thread_local. 
//          Builtin dataclass with automatic .[description], serialization etc would be nice. Syntax should be 
//              super small delta from C struct declaration / designated initializer. 
//              (We already implemented this in current objc in mac-mouse-fix with the MFSimpleDataClass and minimal macros.)
//          Advertise as 'memory-safe in practice' or 'pragmatically memory-safe' C superset.
//              -> Safely and conveniently use super-fast C APIs.
//              Say how you don't have to malloc anything, you don't have to do pointer arithmetic, there are no footguns, you get refcounted objects 
//              for everything and they are super fast and convenient and easy.
//              You *can* also use C APIs, but you can just box the return values immediately, so there is no error-prone malloc / free / realloc you have to do. 
//                  (And that's very fast, too, so for most applications there's never a reason not to have your heap memory managed by ARC.)
//              While it may not have a complicated compile-time prover that you're doing nothing wrong, the language is simple and lean and understandabe, and designed 
//                  so it's hard to do anything wrong by accident. (Worst case, you leak some memory but that's not the end of the 
//                  world and easy to fix, with our Apple Instruments TM Suite)
//              It's a C superset, so you still get the full power and speed of C when you need it. But for heap allocations, buffers 
//                  and ownership, the most tedious and error prone parts of C – you can just box things in objects 
//                  – it will most likely be more than fast enough anything you'll ever wanna do.
//                      (Maybe have some sugar for a boxed, typed, arc-managed C-buffer? 
//                      NSMutableData is already almost that – just lacks typing cause lightweight generics don't support C-types)
//              -> This is the pitch for low-level / system programmers as an alternative to C or Rust for command-line tools or scripting etc. 
//                  Regular app devs live in the world of AppKit/UIKit anyways, and so don't even have to worry about calling C APIs very much I guess, 
//                  although, some of them are actually nice to use and useful, so maybe it would be nice to help app-devs be more comfortable using them 
//                  directly, too, instead of higher-level wrappers?
//              -> You don't need a wrapper when you can just wrap anything yourself in 1 line of code and call ALL the C APIs your system offers, 
//                      with scripting-language-like convenience.
//                      (Also auto completion is better and man pages are easier to read than Python docs, so you might be *more* productive)
//          List comprehensions:
//              Idea: 
//                  @[<loop-body-expression-evaluating-to-object> <loop-header>]
//                  (Would work with any C loop header – for, while, do-while)
//              Example:
//                  struct dirent *entry;
//                  Array [String *] *files = @[ @(String *)entry->d_name while ((entry = readdir(dir))) ]; /// This is so elegant!!
//                  
//              Equivalent without list-comprehension:
//                  struct dirent *entry;
//                  Array [String *] *files = Array.[new];
//                  while ((entry = readdir(dir))) 
//                      files.[addObject: @(String *)entry->d_name];
//          Replace `[NSString stringWithFormat: @"%@", obj]` -> `@"%@".[format: obj]`
//              ... Honestly stringf(@"%@", obj) is still more readable when you have more args.
//          Remove arbitrary restrictions from anonymous structs to allow multiple return values:
//              `struct { auto x; int y; } result = f();`
//              `struct { auto x, y; } result     = f();` 
//              `struct { auto x, y; }            = f();` 
//                  This would insert x and y directly into the enclosing scope. 
//                      consistent with that microsoft extension where you can do this:
//                      `struct A { int a, b; }`
//                      `struct B { struct A; int c, d; }`
//              `struct { x; int y; }            = f();`  /// Assign to x if it already exists in-scope 
//                                                        ///      - this one is a bit weird, cause now it's not really standard struct syntax anymore?

    /// Swuft 2.0

        /// Dot-syntax

            - (String *) description {

                auto content = @"";
                Array [String *] *propNames = self.[class].[propNames];
                if (propNames.[count] > 0) {
                
                    thread_local auto visited = Array.[new];
                    auto *s = @(auto)(uintptr_t)self;
                    bool found_circref = visited.[contains: self];
                    visited.[add: s];
                    defer {
                        assert(visited.[last].[equals: s]);
                        visited.[removeLast];
                    };
                    
                    if ((0))
                        content = self.[asPlist_SecureCoding: NO].[description];
                    else if (found_circref)
                        content = @"<This object has appeared in the description before. Stopping here to prevent infinite recursion.>";
                    else {
                        
                        content = 
                            @[stringf(@"%@: %@", name, self.[kvc_get: name]) for (String *name in propNames)]
                            .[joinedBy: @"\n"];
                    }
                }
            }
            
        /// FULL smalltalk:

            - (String *) description {

                auto content = @"";
                Array [String *] *propNames = self class propNames;
                if (propNames count > 0) {
                
                    thread_local auto visited = Array new;
                    auto *s = @(auto)(uintptr_t)self;
                    bool found_circref = visited [contains: s];
                    visited [add: s];
                    defer {
                        assert(visited last [equals: s]);
                        visited removeLast;
                    };
                    
                    if ((0))
                        content = self [asPlist_SecureCoding: NO] description;
                    else if (found_circref)
                        content = @"<This object has appeared in the description before. Stopping here to prevent infinite recursion.>";
                    else {
                        content = 
                            @[stringf(@"%@: %@", name, self [kvc_get: name]) for (String *name in propNames)] 
                            [joinedBy: @"\n"];
                    }
                }
            }


    /// Swuft vs Python vs C for UNIX scripting

        /// Swuft
        ///     (Uses the same APIs as C and is probably within 10% performance!!)

            int main() {
                
                DIR *dir = opendir("/etc");
                defer closedir(dir);
                struct dirent *entry;
                auto files = @[ @(String *)entry->d_name while ((entry = readdir(dir))) ]; /// This is so elegant!!

                auto info = @{ 
                    @"path": @"/etc", 
                    @"files": files, 
                    @"count": @(auto)(files.[count]);
                };
                
                printf("%s\n", @(char *)(info.[toJSON]);
            }
        
        /// Python

            files = os.listdir("/etc")
            info = {
                "path": "/etc", 
                "files": files, 
                "count": len(files)
            }
            print(json.dumps(info))

        /// C
        ///     (Written by Claude, may be more verbose than necessary to prove a point)

            int main() {
                DIR *dir = opendir("/etc");
                struct dirent *entry;
                char **names = NULL;
                int count = 0;
                
                while ((entry = readdir(dir))) {
                    names = realloc(names, (count + 1) * sizeof(char *));
                    names[count] = strdup(entry->d_name);
                    count++;
                }
                closedir(dir);
                
                // manual JSON construction...
                printf("{\"path\": \"/etc\", \"files\": [");
                for (int i = 0; i < count; i++) {
                    if (i) printf(",");
                    printf(names[i]);
                    free(names[i]);
                }
                printf("], \"count\": %d}\n", count);
                free(names);
            }


            /** Deeply nested calls:

            // Current objc
            [[parser parseDocument: [loader 
                fetchURL:   [config get: @"url"] 
                withAuth:   [credentials tokenFor: [service current]]
                andTimeout: [[settings get: @"timeout"] intValue]]
            ]]
            validateWith: [schema load: @"doc.xsd"]];


            // Dot-bracket
            parser.[parseDocument: loader.[
                fetchURL:   config.[get: @"url"] 
                withAuth:   credentials.[tokenFor: service.[current]]
                andTimeout: settings.[get: @"timeout"].[intValue]
            ]]
            .[validateWith: schema.[load: @"doc.xsd"]];

            // smalltalk-objc
            parser [parseDocument: loader [
                fetchURL:   config [get: @"url"] 
                withAuth:   credentials [tokenFor: service current]
                andTimeout: settings [get: @"timeout"] intValue
            ]]
            [validateWith: schema [load: @"doc.xsd"]];

            // Swift
            parser.parseDocument(loader.fetch(
                url:     config.get("url"),
                auth:    credentials.token(for: service.current),
                timeout: settings.get("timeout").intValue
            ))
            .validate(with: schema.load("doc.xsd"))

            // Dot-parens
            //      (Look too similar to function-call I think? `.(intValue)` looks like intValue is the rvalue)
            parser.(parseDocument: loader.(
                fetchURL:   config.(get: @"url")
                withAuth:   credentials.(tokenFor: service.(current))
                andTimeout: settings.(get: @"timeout").(intValue)
            ]]
            .(validateWith: schema.(load: @"doc.xsd"));

            */